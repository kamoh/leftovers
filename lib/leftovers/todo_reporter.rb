# frozen_string_literal: true

require 'pathname'

module Leftovers
  class TodoReporter
    def prepare
      return unless path.exist?

      puts "Removing previous #{path.basename} file"
      puts ''
      path.delete
    end

    def report(only_test:, none:)
      path.write(generate_file_body(only_test, none))
      report_instructions

      0
    end

    def report_success
      puts "No #{path.basename} file generated, everything is used"

      0
    end

    private

    def report_instructions
      puts <<~MESSAGE
        generated #{path.basename}.
        running leftovers again will read this file and not alert you to any unused items mentioned in it.

        commit this file so you/your team can gradually address these items while still having leftovers alert you to any newly unused items.
      MESSAGE
    end

    def path
      Leftovers.pwd.join('.leftovers_todo.yml')
    end

    def generate_file_body(only_test, none)
      <<~YML.chomp
        #{generation_message.chomp}
        #
        #{resolution_instructions}
        #{todo_data(only_test, none).chomp}
      YML
    end

    def generation_message
      <<~YML
        # This file was generated by `leftovers --write-todo`
        # Generated at: #{Time.now.utc.strftime('%F %T')} UTC
      YML
    end

    def resolution_instructions
      <<~YML
        # for instructions on how to address these
        # see #{Leftovers.resolution_instructions_link}
      YML
    end

    def todo_data(only_test, none)
      none_test = none.select(&:test?)
      none_non_test = none.reject(&:test?)
      [
        test_only_data(none_test),
        keep_data(only_test, none_non_test)
      ].compact.join
    end

    def test_only_data(list)
      return if list.empty?

      <<~YML
        test_only:
        #{generate_list('Defined in tests:', list).chomp}
      YML
    end

    def keep_data(only_test, none_non_test)
      return if only_test.empty? && none_non_test.empty?

      <<~YML.chomp
        keep:
        #{keep_test_called_data(only_test)}#{keep_never_called_data(none_non_test)}
      YML
    end

    def keep_test_called_data(list)
      return if list.empty?

      generate_list('Only directly called in tests:', list)
    end

    def keep_never_called_data(list)
      return if list.empty?

      generate_list('Not directly called at all:', list)
    end

    def generate_list(title, list)
      <<~YML
          # #{title}
        #{list.map { |d| print_definition(d) }.join("\n")}

      YML
    end

    def print_definition(definition)
      "  - #{definition.to_s.inspect} # #{definition.location_s} #{definition.source_line.strip}"
    end

    def puts(string)
      Leftovers.puts(string)
    end
  end
end
